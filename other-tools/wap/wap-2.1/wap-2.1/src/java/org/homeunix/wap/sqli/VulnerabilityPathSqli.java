/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.homeunix.wap.sqli;

import org.homeunix.wap.table.tainted.*;
import org.homeunix.wap.table.symbol.*;
import java.util.*;
import org.homeunix.wap.utils.*;


/**
 *
 * @author iberiam
 */
public class VulnerabilityPathSqli extends Symbol implements Scope{
    Scope scope;
    Scope parent;
    
    // *** CONSTRUCTOR
    public VulnerabilityPathSqli(Scope scp) {
        super(scp.getScopeSymbol().getName(), scp.getScopeSymbol().getTainted(), scp.getScopeSymbol().getCodeLine(), scp.getScopeSymbol().getFileSymbol());
        this.scope = scp;
        this.parent = scp.getEnclosingScope();
    }

    // *** METHODS

    // give the scope name
    public String getScopeName() {
    	return this.getName();
    }

    // am I nested in another?
    public Scope getEnclosingScope() {
        return this.parent;

    }
  
    // give the root symbol of the scope
     public Symbol getScopeSymbol() {
    	return super.getSymbol();
    }

    public List getMembers() {
        return this.scope.getMembers();
    }
    
    // colecta as linhas do vuln path
    //public String buildCorrectSQL(String connDB, String nameDB, int lineMysqliBindParam, List UserInput, TaintedTable mts_princ, SymbolTable st, LinesToCorrect MapLinesToCorrect, Map MainLinesToCorrect) {
    public VulnerSQLI collectVulnPathSQL(String connDB, String nameDB, int lineMysqliBindParam, List UserInput, TaintedTable mts_princ, SymbolTable st, Boolean insideUserFunction, Map MainLinesToCorrect) {    
        String sql_final, mysqlFunc;
        int linhaScope = this.getScopeSymbol().getCodeLine();
        String fileScope = this.getScopeSymbol().getFileSymbol();
        ListVulners lv;
        
        int indiceMysqlEscapeFunc = -1;
        /*
         * indiceMysqlEscapeFunc value
         * ---- MySQL
         * 0 - mysql_real_escape_string
         * 1 - mysqli_real_escape_string
         * 2 - real_escape_string (mysqli oo)
         * ---- DB2
         * 3 - db2_escape_string
         * ---- PostgreSQL
         * 4 - pg_escape_string
         * 5 - pg_escape_bytea
         */
              

        // Criar estrutura para armazenar as vulnerabilidades encontradas
        if (GlobalDataSqli.MainListVulners.containsKey(fileScope) == false){
            lv = new ListVulners(fileScope);
            GlobalDataSqli.MainListVulners.put(fileScope, lv);
        }
        else
            lv = GlobalDataSqli.MainListVulners.get(fileScope);

        mysqlFunc = this.getScopeName();
        
        // Adicionar a linha da vulnerabilidade
        VulnerSQLI vul = new VulnerSQLI(linhaScope, fileScope, mysqlFunc, lineMysqliBindParam);
        
        /*
         * MySQL e MySQLi
         */
        if (GlobalDataApp.dbms.equals("mysql")){          
            if (mysqlFunc.equals("mysql_db_query")){
                mysqlFunc = "mysql_query";
                //mysql_db_query = 1;
                vul.setDecreptedMysqlFuncToSubst("mysql_query");
                //vul.setMysql_db_query(1);
            }

            if (mysqlFunc.equals("mysqli_execute")){
                //mysqli_execute = 1;
                vul.setDecreptedMysqlFuncToSubst("mysqli_stmt_execute");
                //vul.setMysqli_execute(1);
            }

            if (mysqlFunc.equals("mysql_query") || mysqlFunc.equals("mysql_unbuffered_query")){
                indiceMysqlEscapeFunc = 0;
            }
            else{
                if (mysqlFunc.equals("mysqli_query") || mysqlFunc.equals("mysqli_real_query") || mysqlFunc.equals("mysqli_master_query") || mysqlFunc.equals("mysqli_multi_query")){
                    indiceMysqlEscapeFunc = 1;
                }
                else{
                    if (mysqlFunc.equals("query") || mysqlFunc.equals("real_query") || mysqlFunc.equals("multi_query")){
                        indiceMysqlEscapeFunc = 2;
                    }
                }
            }           
        }

        /*
         * BD2
         */
        if (GlobalDataApp.dbms.equals("db2")){
            if (mysqlFunc.equals("db2_exec")){
                indiceMysqlEscapeFunc = 3;
            }
        }

        /*
         * PostgreSQL
         */
        if (GlobalDataApp.dbms.equals("pg")){
            if (mysqlFunc.equals("pg_query") || mysqlFunc.equals("pg_send_query")){
                indiceMysqlEscapeFunc = 4;
            }
        }

        vul.setIndiceMysqlEscapeFunc(indiceMysqlEscapeFunc);
        lv.getListOfVulners().add(vul);
        GlobalDataSqli.currentVulner = vul;

        try{
        sql_final = this.collectStmt(this, "", indiceMysqlEscapeFunc, false, connDB, nameDB, UserInput, mts_princ, st, MainLinesToCorrect);       
        } catch (Exception e){}
        
        return GlobalDataSqli.currentVulner;
    }

    
    public String collectStmt(VulnerabilityPathSqli sc, String codeLine, int indiceMysqlEscapeFunc, Boolean moveUP, String connDB, String nameDB, List UserInput, TaintedTable mts_princ, SymbolTable st, Map MainLinesToCorrect){    
        VulnerabilityPathSqli scp = this;
        Iterator <Symbol> it;
        String s = "", stmt="", concatenation="", builEscapeFunc = "", escapeFunc = "";

        for (it = scp.getMembers().iterator(); it.hasNext();){
            Symbol sym = it.next();            
            if (sym.getAlfanumeric())               
                sym.setNameMultiline();
               
            if (sym.getRootScope() == null && sym.getName().equals(connDB) == false && sym.getName().equals(nameDB) == false){
                if (sym.getTainted() == 1){    
                    if (sym.getAlfanumeric() == true){
                        if (GlobalDataSqli.currentVulner.getLineToSanitize() < 0){
                            GlobalDataSqli.currentVulner.setLineToSanitize(sym.getCodeLine());
                            GlobalDataSqli.currentVulner.setFileOfLineToSanitize(sym.getFileSymbol());
                          /*
                            ManageFiles fff = new ManageFiles (sym.getFileSymbol());
                            codeLine = fff.getLineOfCode(sym.getCodeLine());                                    
                            GlobalDataSqli.currentVulner.setVulCode(codeLine);
                            GlobalDataSqli.currentVulner.setCorrectedCode(codeLine);                            
                           */
                            GlobalDataSqli.currentVulner.setVulCode(sym.getName());
                        }                      
                        try{
                        // procurar posicoes para a correcao, o resto do vv path e os atributos dm
                        stmt = collectStmtAlphanumeric(sym, connDB, nameDB, UserInput, escapeFunc, mts_princ, indiceMysqlEscapeFunc, st, MainLinesToCorrect);
                        } catch (Exception e){}
                        
                        // collect attributes to DM
                        String cod;
                        if (codeLine != "")
                            cod = codeLine;
                        else{
                            ManageFiles fff = new ManageFiles (sym.getFileSymbol());
                            cod = fff.getLineOfCode(sym.getCodeLine());                            
                        }
                        GlobalDataSqli.currentVulner.getVectorAttributesOfVulner().collectAttributes(cod, sym.getCodeLine(), sym.getFileSymbol(), true, GlobalDataSqli.currentVulner);
                        
                    }
                    else{// sym is a entry point or a var
                        Boolean iHaveFound = false;
                        String ui;
                        Iterator <String> it1 = UserInput.listIterator();
                        for (;it1.hasNext();){
                            ui = it1.next();
                            if (sym.getName().contains(ui) && sym.getName().startsWith("$"+ui+"[")){
                                iHaveFound = true;
                                break;
                            }
                        }
                        
                        // $_POST, ...
                        if (iHaveFound == true){
                            if (sym.getCodeLine() == GlobalDataSqli.currentVulner.getLineToSanitize()
                                && GlobalDataSqli.currentVulner.getIndiceMysqlEscapeFunc() > -1){
                                String f = GlobalDataSqli.currentVulner.getCorrectedCode();
                                String escapeString = "san_sqli(" + indiceMysqlEscapeFunc + ", " + sym.getName() + ")";
                                f = f.replace(sym.getName(), escapeString);
                                if (f != "")
                                    GlobalDataSqli.currentVulner.setCorrectedCode(f);
                                stmt = f;
                            }
                            
                            // collect attributes to DM                            
                            GlobalDataSqli.currentVulner.setTaintedInputElements(sym.getCodeLine(), sym.getFileSymbol(), sym.getName());
                            String cod;
                            if (codeLine != "")
                                cod = codeLine;
                            else{
                                ManageFiles fff = new ManageFiles (sym.getFileSymbol());
                                cod = fff.getLineOfCode(sym.getCodeLine());                            
                            }
                            GlobalDataSqli.currentVulner.getVectorAttributesOfVulner().collectAttributes(cod, sym.getCodeLine(), sym.getFileSymbol(), true, GlobalDataSqli.currentVulner);                            
                            
                            
                                if(codeLine.isEmpty() == true && sym.getScope().getScopeName().equals("concatenation")){
                                    ManageFiles fff = new ManageFiles (sym.getFileSymbol());
                                    codeLine = fff.getLineOfCode(sym.getCodeLine());
                                }
                              

                        }
                        else{ // $a, $query...
                            if (sym.getIsVariableSymbol()){
                                if (sym.getCodeLine() == GlobalDataSqli.currentVulner.getLineToSanitize()
                                    && GlobalDataSqli.currentVulner.getIndiceMysqlEscapeFunc() > -1){
                                    String f = GlobalDataSqli.currentVulner.getCorrectedCode();
                                    String escapeString = "san_sqli(" + indiceMysqlEscapeFunc + ", $" + sym.getName() + ")";                                    
                                    f = f.replace("$"+sym.getName(), escapeString);                         
                                    if (f.equals("") == false)
                                        GlobalDataSqli.currentVulner.setCorrectedCode(f);
                                    stmt = f; 
                                }
                            try{
                                String s3 = collectStmtVariable(indiceMysqlEscapeFunc, sym, true, connDB, nameDB, UserInput, mts_princ, st, MainLinesToCorrect);
                            } catch (Exception e){}
                                
                                // collect attributes to DM                            
                                GlobalDataSqli.currentVulner.setTaintedInputElements(sym.getCodeLine(), sym.getFileSymbol(), "$" + sym.getName());
                                String cod;
                                if (codeLine != "")
                                    cod = codeLine;
                                else{
                                    ManageFiles fff = new ManageFiles (sym.getFileSymbol());
                                    cod = fff.getLineOfCode(sym.getCodeLine());                            
                                }
                                GlobalDataSqli.currentVulner.getVectorAttributesOfVulner().collectAttributes(cod, sym.getCodeLine(), sym.getFileSymbol(), true, GlobalDataSqli.currentVulner);
                            }     
                        }
                    }
                }
                else{
                    // Se for alfanumerico, nao tainted e inicio de instrucao SQL
                    if (sym.getAlfanumeric() == true){
                        if (GlobalDataSqli.currentVulner.getLineToSanitize() < 0){
                            String upper = sym.getName();
                            upper = upper.toUpperCase();
                            String sql_key;
                            Iterator <String> it1 = GlobalDataSqli.SQLKeywords.listIterator();
                            for (;it1.hasNext();){
                                sql_key = it1.next();                               
                                if (upper.startsWith(sql_key, 1)){
                                    GlobalDataSqli.currentVulner.setLineToSanitize(sym.getCodeLine());
                                    GlobalDataSqli.currentVulner.setFileOfLineToSanitize(sym.getFileSymbol());
                                    ManageFiles fff = new ManageFiles (sym.getFileSymbol());
                                    codeLine = fff.getLineOfCode(sym.getCodeLine());                                    
                                    GlobalDataSqli.currentVulner.setVulCode(codeLine);
                                    GlobalDataSqli.currentVulner.setCorrectedCode(codeLine);
                                    stmt = codeLine;
                                    break;
                                }
                            }                            
                        }
                    }
                }
                    
            }
            else{
                if (sym.getName().equals(connDB) == false && sym.getName().equals(nameDB) == false){
                    // chamada de funcao definida pelo utilizador
                    TaintedTable mts_aux = null;                     
                    try{
                        mts_aux = getMtsUserFunction(st, sym);
                    } catch (Exception e){}

                    if (sym.getIsFunction() == true && mts_aux != null){
                        stmt = collectStmtVariable(indiceMysqlEscapeFunc, sym, true, connDB, nameDB, UserInput, mts_aux, st, MainLinesToCorrect);
                    }
                    else{
                        Scope scp11 = (Scope)sym.getRootScope();
                        VulnerabilityPathSqli scp1 = new VulnerabilityPathSqli(scp11);
                        try{
                        stmt = scp1.collectStmt(sc, "", indiceMysqlEscapeFunc, moveUP, connDB, nameDB, UserInput, mts_princ, st, MainLinesToCorrect);
                        }catch (Exception e){}
                    }
                }
            }      
        }
        
        return stmt;
    }    
    
    private String collectStmtAlphanumeric(Symbol sym, String connDB, String nameDB, List UserInput, String escapeFunc, TaintedTable mts_princ, int indiceMysqlEscapeFunc, SymbolTable st, Map MainLinesToCorrect){    
        String final_str="\"", a = "", aa, leftside_a, rest_a, userinput = "", escapeString = "", aux;
        String final_str_aux;
        int indice_input, open_square_brace, j=0;
        Iterator <RootTaintedSymbol> it1;
        RootTaintedSymbol raux;
        char chars[];
        ArrayList lista =new ArrayList(); // array que armazena os indices onde aparecem os UserInput ($_POST...)
        ArrayList lista_len =new ArrayList(); // array que armazena os tamanhos onde aparecem os UserInput ($_POST...)
        Boolean foundVar = false;

        if (sym.getCodeLine() == GlobalDataSqli.currentVulner.getLineToSanitize()
                && GlobalDataSqli.currentVulner.getIndiceMysqlEscapeFunc() > -1){
            
            // Procura os indices dos UserInput na string em analise
            Iterator <String> it = UserInput.listIterator();
            for (;it.hasNext();){
                aux = it.next();
                indice_input = 0; // index do input encontrado na string em analise
                a = sym.getName(); 
                while (a.contains("$"+aux+"[") == true){
                    lista.add(a.indexOf(aux) + indice_input - 1);
                    indice_input = indice_input + a.indexOf(aux) + aux.length();
                    a = a.substring(a.indexOf(aux) + aux.length());
                }
            }
            Collections.sort(lista);
        
            if (lista.size() > 0){
                GlobalDataSqli.currentVulner.getPositionSanFunction().addAll(lista);
        
                // Obter o tamanho dos user inputs
                indice_input = 0;
                a = sym.getName();
                for(int i=0; i < lista.size(); i++){
                    leftside_a = a.substring(1, (Integer)lista.get(i)-indice_input-j-1);
                    rest_a = a.substring((Integer)lista.get(i)-indice_input-j);
                    indice_input = (Integer)lista.get(i);

                    j = 0;
                    chars = rest_a.toCharArray();
                    while (chars[j] != '[')
                        j++;

                    j++;
                    open_square_brace = 1;
                    while (open_square_brace != 0){
                        if (chars[j] == '[')
                            open_square_brace++;
                        if (chars[j] == ']')
                            open_square_brace--;
                        j++;
                    }
                    
                    lista_len.add(j);
                    
                    userinput = rest_a.substring(0, j);
                    a = rest_a.substring(j);

                    GlobalDataSqli.currentVulner.setTaintedInputElements(sym.getCodeLine(), sym.getFileSymbol(), userinput);
                    escapeString = "san_sqli(" + indiceMysqlEscapeFunc + ", " + userinput + ")";
                    final_str = final_str + leftside_a + "\'\"." + escapeString + ".\"\'";
                }
                GlobalDataSqli.currentVulner.getLenghtSanFunction().addAll(lista_len);
            }

        
                if (a.startsWith("\'"))
                    a = a.substring(1, a.length());
                else
                    a = a.substring(0, a.length());
                
                final_str = final_str + a;
                a = final_str;

            if (a.equals(sym.getName()) == false && final_str != "")               
                GlobalDataSqli.currentVulner.setCorrectedCode(final_str);
            
        }
     
        if (lista.isEmpty()){
            a = sym.getName();
            final_str = a;
        }        
        
        final_str_aux = a;
        
        // Procura os indices das Tainted vars na string em analise e faz correcao automatica
        it1 = mts_princ.getTaintedMembers().values().iterator();
        lista.clear();
        lista_len.clear();
        for (;it1.hasNext();){
            raux = it1.next();
            aux = raux.getName();
            
            indice_input = 0; // index do input encontrado na string em analise
            while (a.contains("$"+aux+"\'") == true || a.contains("$"+aux+" ") == true){
                if (a.contains("$"+aux+"\'"))
                    j = a.indexOf("$"+aux+"\'");
                else
                    j = a.indexOf("$"+aux+" ");
                
                lista.add(j + indice_input);
                indice_input = indice_input + j + aux.length();
                a = a.substring(j + aux.length()+1);
            }
            a = final_str;
        }
            Collections.sort(lista);
            
            if (sym.getCodeLine() == GlobalDataSqli.currentVulner.getLineToSanitize()
                    && GlobalDataSqli.currentVulner.getIndiceMysqlEscapeFunc() > -1){            
                if (lista.size() > 0){
                    foundVar = true;
                    GlobalDataSqli.currentVulner.getPositionSanFunction().addAll(lista);         

                    // Obter o tamanho das vars
                    j = 0;
                    indice_input = 0;
                    a = final_str;
                    final_str = "\"";
                    for(int i=0; i < lista.size(); i++){
                        leftside_a = a.substring(1, (Integer)lista.get(i)-indice_input-j-1);
                        rest_a = a.substring((Integer)lista.get(i)-indice_input-j);
                        indice_input = (Integer)lista.get(i);

                        j = 0;
                        chars = rest_a.toCharArray();
                        while (chars[j] != '\'' && chars[j] != ' ')
                            j++;

                        lista_len.add(j);

                        userinput = rest_a.substring(0, j);
                        a = rest_a.substring(j);

                        GlobalDataSqli.currentVulner.setTaintedInputElements(sym.getCodeLine(), sym.getFileSymbol(), userinput);
                        escapeString = "san_sqli(" + indiceMysqlEscapeFunc + ", " + userinput + ")";
                        final_str = final_str + leftside_a + "\'\"." + escapeString + ".\"\'";
                    }            
                GlobalDataSqli.currentVulner.getLenghtSanFunction().addAll(lista_len);         

                final_str = final_str + "\"";
                if (a.equals(sym.getName()) == false && final_str != "")
                    GlobalDataSqli.currentVulner.setCorrectedCode(final_str);
                }
        }
        
        if (foundVar == true){
            a = final_str_aux;
            it1 = mts_princ.getTaintedMembers().values().iterator();
            for (;it1.hasNext();){
                raux = it1.next();
                aux = raux.getName();
                for(int i=0; i < lista.size(); i++){
                    userinput = a.substring((Integer)lista.get(i)+1, (Integer)lista.get(i) + (Integer)lista_len.get(i));

                    if (userinput.equals(aux)){
                        Symbol symb = new Symbol(userinput, 1, sym.getCodeLine(), sym.getFileSymbol());
                        symb.setIsVariableSymbol(true);
                        symb.setScope(sym.getScope());
                        userinput = "$" + userinput;
                        try{
                            collectStmtVariable(indiceMysqlEscapeFunc, symb, true, connDB, nameDB, UserInput, mts_princ, st, MainLinesToCorrect);
                        }catch (Exception e){}
                        
                        // collect attributes to DM                            
                        GlobalDataSqli.currentVulner.setTaintedInputElements(sym.getCodeLine(), sym.getFileSymbol(), userinput);
                        String cod;
                        ManageFiles fff = new ManageFiles (sym.getFileSymbol());
                        cod = fff.getLineOfCode(sym.getCodeLine());                            
                        GlobalDataSqli.currentVulner.getVectorAttributesOfVulner().collectAttributes(cod, sym.getCodeLine(), sym.getFileSymbol(), true, GlobalDataSqli.currentVulner);                        
                    }
                }
            }
        }
        
        return final_str;
    }
    
   private String collectStmtVariable(int indiceMysqlEscapeFunc, Symbol sym, Boolean moveUP, String connDB, String nameDB, List UserInput, TaintedTable mts_princ, SymbolTable st, Map MainLinesToCorrect){    
       String stmt = "";
       int i, j, indiceScopeSymbol;
       RootTaintedSymbol Rrt;
       RelatedTaintedSymbol rtt;
       VariableTaintedSymbol vts;
       VulnerabilityPathSqli scp = null;
       TaintedTable mts_aux;
       SymbolTable st_aux = null;
       ArrayList listaIndiceLineTainted =new ArrayList(); // lista que armazena os indices das linhas das vars de mysql em st
       
       indiceScopeSymbol = sym.getScope().getScopeSymbol().getCodeLine(); // linha onde encontrou a var em mysql
       String nameScopeSymbol;
       
       if (sym.getIsFunction() == true)
            nameScopeSymbol = sym.getName();
       else
            nameScopeSymbol = sym.getScope().getScopeName(); // nome do scope em mysql


       LineAndFileRrt lf = new LineAndFileRrt();
       Integer linhaRrt;
       String fileRrt = "";
       boolean foundlf;
       mts_aux = mts_princ;
       foundlf = foundLineAndFileRrt(lf, sym, nameScopeSymbol, indiceScopeSymbol, mts_aux);
       if (foundlf == false){
            if (GlobalDataSqli.MainTaintedTable.containsKey(sym.getFileSymbol()) == true){
                mts_aux = GlobalDataSqli.MainTaintedTable.get(sym.getFileSymbol());
                foundlf = foundLineAndFileRrt(lf, sym, nameScopeSymbol, indiceScopeSymbol, mts_aux);
            }
            if (foundlf == false){
                if (GlobalDataSqli.MainFunctionsTaintedTable.containsKey(sym.getFileSymbol()) == true){
                    MethodTaintedTable mtt = GlobalDataSqli.MainFunctionsTaintedTable.get(sym.getFileSymbol());
                    Iterator <MethodSymbolTainted> it;
                    for(it = mtt.getListTaintedMembers().iterator(); it.hasNext();){
                        MethodSymbolTainted mstt = it.next();
                        mts_aux = mstt.getFunctionTaintedTable();
                        foundlf = foundLineAndFileRrt(lf, sym, nameScopeSymbol, indiceScopeSymbol, mts_aux);
                        if (foundlf == true)
                            break;
                    }
                }
            }
       }

          linhaRrt = lf.getLinhaRrt();
          fileRrt = lf.getFileRrt();         
          
            // Obter Symbol Table
           String n = "";
           if (sym.getIsFunction() == true)
               n = "return";
           else
               n = sym.getName();
          
          boolean found = false;
          
            //1. Ver na st actual
            try{
            st_aux = st;
            Symbol syy;
            for (Iterator <Symbol> it = st_aux.getMembers().iterator(); it.hasNext(); ){
                syy = it.next();                       
                if (syy.getIsVariableSymbol() == false){
                    Scope sy = (Scope) syy; 
                    if (sy.getScopeSymbol().getName().equals(n) && sy.getScopeSymbol().getCodeLine() == linhaRrt){
                        scp = new VulnerabilityPathSqli(sy);
                        found = true;
                        break;
                    }
                }
            }
            } catch (Exception e) {}

            // 2. Ver nas tabela dos outros files
            try{
            if(found == false){
                if (GlobalDataSqli.MainSymbolTable.containsKey(fileRrt) == true){
                    st_aux = GlobalDataSqli.MainSymbolTable.get(fileRrt);

                    // verificar se a linhaRrt e symName fazem parte deste st
                    // Poderá ser uma linha de uma UserFunction. Caso não esteja em em staux ver nos st's das fucnçoes
                    found = false;
                    for (Iterator <Symbol> it = st_aux.getMembers().iterator(); it.hasNext(); ){
                        Scope sy = (Scope) it.next();
                        if (sy.getScopeSymbol().getName().equals(sym.getName()) && sy.getScopeSymbol().getCodeLine() == linhaRrt){
                            scp = new VulnerabilityPathSqli(sy);
                            found = true;
                            break;
                        }
                    }
                    
                    for (Iterator <Symbol> it = st_aux.getMembers().iterator(); it.hasNext(); ){
                        Scope sy = (Scope) it.next();
                        if (sy.getScopeSymbol().getCodeLine() == linhaRrt){
                            // Procura Scope do sym
                            Scope sc = foundScope(sy, sym.getName());
                            scp = new VulnerabilityPathSqli(sc);
                            found = true;
                            break;
                        }
                    }             
                }
            }
            } catch (Exception e) {}

            // 3. ver nos includes files
            try{
            if(found == false){
                if (GlobalDataSqli.MainIncludeFilesTable.containsKey(fileRrt) == true){
                    st_aux = GlobalDataSqli.MainIncludeFilesTable.get(fileRrt);

                    // verificar se a linhaRrt e symName fazem parte deste st
                    // Poderá ser uma linha de uma UserFunction. Caso não esteja em em staux ver nos st's das fucnçoes
                    found = false;
                    for (Iterator <Symbol> it = st_aux.getMembers().iterator(); it.hasNext(); ){
                        Scope sy = (Scope) it.next();
                        if (sy.getScopeSymbol().getName().equals(sym.getName()) && sy.getScopeSymbol().getCodeLine() == linhaRrt){
                            scp = new VulnerabilityPathSqli(sy);
                            found = true;
                            break;
                        }
                    }
                    
                    for (Iterator <Symbol> it = st_aux.getMembers().iterator(); it.hasNext(); ){
                        Scope sy = (Scope) it.next();
                        if (sy.getScopeSymbol().getCodeLine() == linhaRrt){
                            // Procura Scope do sym
                            Scope sc = foundScope(sy, sym.getName());
                            scp = new VulnerabilityPathSqli(sc);
                            found = true;
                            break;
                        }
                    }             
                }
           }
            } catch (Exception e) {}            
                   
           // 4. ver em user functions
           try{
           if (found == false){
               String aa = fileRrt;
               // Aqui o fileRrt e' o nome da Userfunction que esta a ser analisada
               ManageFiles fff = new ManageFiles (fileRrt);
               if (fileRrt.equals(nameScopeSymbol) == false && fff.existFile(fileRrt) == false)
                    aa = sym.getFileSymbol();
                
               if (GlobalDataSqli.MainFunctionsCallsTable.containsKey(aa) == true){
                    MethodTableCalls mtc = GlobalDataSqli.MainFunctionsCallsTable.get(aa);
                    
                    for (Iterator <MethodSymbolCall> it = mtc.getListMethodsMembers().iterator(); it.hasNext(); ){
                        MethodSymbolCall msc = it.next();
                        found = false;
                        for (Iterator <Symbol> it1 = msc.getCallFunctionSymbols().iterator(); it1.hasNext(); ){
                            Scope sy = (Scope) it1.next();
                            if (sy.getScopeSymbol().getName().equals(n) && sy.getScopeSymbol().getCodeLine() == linhaRrt){
                                scp = new VulnerabilityPathSqli(sy);
                                found = true;
                                st_aux = new SymbolTable(aa);
                                st_aux.setAllSymbols(msc.getCallFunctionSymbols());
                                break;
                            }
                        }
                    }
                }
             }
            } catch (Exception e) {}           

           // 5. ver nos outros files de user functions (ultima hipotese)
           // quando uma user function chamada num file chama outra que pertence a outro file
           try{
           if (found == false){
               String aa = fileRrt;
               MethodTableCalls mtc;
               
               for (Iterator <MethodTableCalls> it2 = GlobalDataSqli.MainFunctionsCallsTable.values().iterator(); it2.hasNext(); ){
                   mtc = it2.next();                                        
                        for (Iterator <MethodSymbolCall> it = mtc.getListMethodsMembers().iterator(); it.hasNext(); ){
                            MethodSymbolCall msc = it.next();
                            found = false;
                            for (Iterator <Symbol> it1 = msc.getCallFunctionSymbols().iterator(); it1.hasNext(); ){
                                Scope sy = (Scope) it1.next();
                                if (sy.getScopeSymbol().getName().equals(n) && sy.getScopeSymbol().getCodeLine() == linhaRrt){
                                    scp = new VulnerabilityPathSqli(sy);
                                    found = true;
                                    st_aux = new SymbolTable(msc.getFunctionNameCall());
                                    st_aux.setAllSymbols(msc.getCallFunctionSymbols());
                                    
                                    MethodTaintedTable mtt = GlobalDataSqli.MainFunctionsTaintedTable.get(mtc.getScopeName());                                    
                                    Iterator <MethodSymbolTainted> it3;
                                    for(it3 = mtt.getListTaintedMembers().iterator(); it3.hasNext();){
                                        MethodSymbolTainted mstt = it3.next();
                                        if (mstt.getFunctionNameCall().equals(msc.getFunctionNameCall()) == true){
                                            mts_aux = mstt.getFunctionTaintedTable();
                                            break;
                                        }
                                    }                                    
                                    break;
                                }
                            }
                            if (found == true)
                                break;                            
                        }  
                   //}
                    if (found == true)
                        break;
               }  
             }
            } catch (Exception e) {}           

                
                    try{ 
                    Scope scpp;
                    Symbol sy;
                    for (Iterator <Symbol> it = st_aux.getMembers().iterator(); it.hasNext(); ){
                        sy = it.next();
                        if (sy.getIsVariableSymbol() == false){
                            scpp = (Scope) sy;
                            if (scpp.getScopeSymbol().getName().equals(n) && scpp.getScopeSymbol().getCodeLine() == linhaRrt){
                                scp = new VulnerabilityPathSqli(scpp);
                                break;
                            }
                        }
                    }                   
                    
                    // buscar linha do ficheiro
                    String codeLine="";
                    //String file = scp.getScopeSymbol().getFileSymbol();
                    //ManageFiles fff = new ManageFiles (file);
                    ManageFiles fff = new ManageFiles (fileRrt);
                    codeLine = fff.getLineOfCode(scp.getScopeSymbol().getCodeLine());
                    if (sym.getFileSymbol().equals(fileRrt) == false){
                        connDB = "";
                        nameDB = "";
                    }

                    // inserir codeLine como linha da vulner corrente
                    GlobalDataSqli.currentVulner.setLineOfVulner(scp.getScopeSymbol().getCodeLine(), fileRrt);
                    if (fileRrt.equals(mts_aux.getScopeTaintedName()) == false){
                        ManageFiles ff = new ManageFiles(fileRrt);
                        if (ff.existFile(fileRrt) == true){
                            try{
                                MethodTable mt = GlobalDataSqli.MainFunctionsTable.get(fileRrt);
                                found = false;
                                if (mt != null){
                                    Iterator <MethodSymbol> it = mt.getMembers().iterator();
                                    MethodSymbol ms;

                                    for (; it.hasNext();){
                                        ms = it.next();
                                        if (ms.getFunctionName().equals(mts_aux.getScopeTaintedName())){
                                            found = true;
                                            break;
                                        }
                                    }
                                }
                                if (found == false){
                                    mts_aux = GlobalDataSqli.MainTaintedTable.get(fileRrt);
                                    try{
                                        st_aux = GlobalDataSqli.MainSymbolTable.get(fileRrt);
                                    } catch (Exception e){
                                        st_aux = GlobalDataSqli.MainIncludeFilesTable.get(fileRrt);
                                    }
                                }
                            } catch (Exception e) {}
                        }
                    }
                   
                    stmt = scp.collectStmt(scp, codeLine, indiceMysqlEscapeFunc, true, connDB, nameDB, UserInput, mts_aux, st_aux, MainLinesToCorrect);
                   } catch (Exception e) {}
                    
       return stmt;
   }
   
   private Boolean foundLineAndFileRrt(LineAndFileRrt lf, Symbol sym, String nameScopeSymbol, int indiceScopeSymbol, TaintedTable mts_aux){
       RootTaintedSymbol Rrt=null;
       RelatedTaintedSymbol rtt;
       VariableTaintedSymbol vts;
       int i, j;
       Integer linhaRrt;
       String fileRrt;
       
       if (sym.getIsFunction() == true){
           if (mts_aux.getTaintedMembers().containsKey("return"))
               Rrt = (RootTaintedSymbol) mts_aux.getTaintedMembers().get("return");
       }
       else{
           if (mts_aux.getTaintedMembers().containsKey(sym.getName()))
                Rrt = (RootTaintedSymbol) mts_aux.getTaintedMembers().get(sym.getName());
       }
       

 //          System.out.println("Rrt: "+Rrt.getScopeTaintedName());
       if(Rrt != null){
           for(i=0; i < Rrt.getLinesList().size(); i++){
                rtt = (RelatedTaintedSymbol) Rrt.getListTaintedMembers().get(i);
                if(rtt.getTaintedMembers().containsKey(nameScopeSymbol)){
                    vts = (VariableTaintedSymbol) rtt.getTaintedMembers().get(nameScopeSymbol);
                    if(vts.getVariableLines().contains(indiceScopeSymbol)){
                        // Analisar os membros do Scope

                        // remove duplicate indexes
                        for(j=0; j < Rrt.getLinesList().size()-1; j++){
                            if (Rrt.getLinesList().get(j) == Rrt.getLinesList().get(j+1)){
                                Rrt.getLinesList().remove(j+1);
                                j--;
                            }
                        }

                        linhaRrt = (Integer) Rrt.getLinesList().get(i);
                        fileRrt = (String) Rrt.getFilesList().get(i);
                        lf.setLinhaFileRrt(linhaRrt, fileRrt);
                        return true;
                    }
                }
           }
       }
       return false;
   }
   
   
   private Scope foundScope(Scope sy, String symName){
       Iterator <Symbol> it = sy.getMembers().iterator();
       Symbol syy;    
       for (; it.hasNext();){
           syy = it.next();
           if (syy.getName().equals(symName) == true)
               return sy;
           else
               return foundScope((Scope)syy, symName);
       }
        return null;
   }
   
  
    private LinesToCorrect getLinesToCorrect(String filename, Map MainLinesToCorrect){
        if (MainLinesToCorrect.containsKey(filename))
            return (LinesToCorrect) MainLinesToCorrect.get(filename);
        else{
            LinesToCorrect l = new LinesToCorrect(filename);
            MainLinesToCorrect.put(filename, l);
            return l;
        }
    }

    // Tell if the symbol is a define user function
    public TaintedTable getMtsUserFunction(SymbolTable st, Symbol sym) {
        TaintedTable mts_aux = null;
        Iterator <MethodSymbolTainted> it;        
        if (st.getHaveFunctions()){
            MethodTaintedTable mtt = GlobalDataSqli.MainFunctionsTaintedTable.get(sym.getFileSymbol());
            for(it = mtt.getListTaintedMembers().iterator(); it.hasNext();){
                MethodSymbolTainted mstt = it.next();
                if (mstt.getFunctionNameCall().equals(sym.getName()) && mstt.getLineNumberCall() == sym.getCodeLine()){
                    mts_aux = mstt.getFunctionTaintedTable();
                    return mts_aux;
                }
            }
        }

        if (st.getIncludeFiles().size() > 0){           
            Iterator <String> it1;
            SymbolTable st_inc;
            String name_st_inc;
            for(it1 = st.getIncludeFiles().iterator(); it1.hasNext();){
                name_st_inc = it1.next();
                st_inc = GlobalDataSqli.MainIncludeFilesTable.get(name_st_inc);
                if (st_inc.getHaveFunctions()){
                    MethodTaintedTable mtt = GlobalDataSqli.MainFunctionsTaintedTable.get(st.getScopeName());
                    for(it = mtt.getListTaintedMembers().iterator(); it.hasNext();){                
                        MethodSymbolTainted mstt = it.next();
                        if (mstt.getFunctionNameCall().equals(sym.getName()) && mstt.getLineNumberCall() == sym.getCodeLine()){                           
                            mts_aux = mstt.getFunctionTaintedTable();                           
                            return mts_aux;
                        }
                    }
                }
            }
        }
        return mts_aux;
    }

    public void define(Symbol sym, Scope scp, Boolean IsVariableSymbol) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public Boolean resolve(Symbol symb, TaintedTable mts, UntaintedTable mus) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public void resolveSymbol(Scope scp, Symbol sy, TaintedTable mts, UntaintedTable mus, String file) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public void resolveSymbolInclude(Scope scp1, TaintedTable mts, UntaintedTable mus) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public String resolveVarInclude(Scope scp, SymbolTable st) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public void print(Scope scp) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    //public void resolveSymbolFunction(MethodSymbol mt, Scope rootScope, TaintedTable mts, UntaintedTable mus, Map mift, String filename, Map mft, Map mst, int vulns, Map varsDB, LinesToCorrect MapLinesToCorrect, Map MainLinesToCorrect) {
    public void resolveSymbolFunctionSQLI(MethodSymbol mt, Scope rootScope, TaintedTable mts, UntaintedTable mus, Map mift, String filename, Map mft, Map mst, Map varsDB, Map mftt, Map MainLinesToCorrect) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public void resolveSymbolIncludeSQLI(Scope scp, TaintedTable mts, UntaintedTable mus, Map mift, String filename, Map mft, Map mst, Map varsDB, Map mftt, Map MainLinesToCorrect) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public Boolean verifyNumberVarList(int num_var){
        throw new UnsupportedOperationException("Not supported yet.");    
    }
    
    public void populateList(Scope scp_left, Scope scp_right, int num_var, TaintedTable mts, UntaintedTable mus, String filename){
        throw new UnsupportedOperationException("Not supported yet.");    
    }    
    
    public Boolean buildCorrectCodeInj(String fileInc, List UserInput, TaintedTable mts_princ, SymbolTable st, Map MainLinesToCorrect){
            throw new UnsupportedOperationException("Not supported yet.");
    }
    
    public Boolean buildCorrectXSS(String fileInc, List UserInput, TaintedTable mts_princ, SymbolTable st, Map MainLinesToCorrect){
            throw new UnsupportedOperationException("Not supported yet.");
    }

    public void resolveSymbolClass(TaintedTable mts, UntaintedTable mus, String filename) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

        public void printtt(String string, Scope cp){
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public void resolveSymbolParam(TaintedTable mts, UntaintedTable mus, String filename) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    public void resolveParam(Symbol symb, TaintedTable mts, UntaintedTable mus) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    public String buildCorrectSQL(String connDB, String nameDB, int lineMysqliBindParam, List UserInput, TaintedTable mts_princ, SymbolTable st, Map MainLinesToCorrect) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    public void copyScope(Scope src, Scope dest) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    public String buildStmt(AutoCorrectSQL scp, String codeLine, int indiceMysqlEscapeFunc, Boolean moveUP, String connDB, String nameDB, List UserInput, TaintedTable mts_princ, SymbolTable st, Map MainLinesToCorrect) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }
}
