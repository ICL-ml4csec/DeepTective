/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.homeunix.wap.CodeInjection;

import org.homeunix.wap.sqli.*;
import org.homeunix.wap.table.tainted.*;
import org.homeunix.wap.table.symbol.*;
import java.util.*;
import org.homeunix.wap.utils.*;


/**
 *
 * @author iberiam
 */
public class VulnerabilityPathCodeInj extends Symbol implements Scope{
    Scope scope;
    Scope parent;
    
    // *** CONSTRUCTOR
    public VulnerabilityPathCodeInj(Scope scp) {
        super(scp.getScopeSymbol().getName(), scp.getScopeSymbol().getTainted(), scp.getScopeSymbol().getCodeLine(), scp.getScopeSymbol().getFileSymbol());
        this.scope = scp;
        this.parent = scp.getEnclosingScope();
    }

    // *** METHODS

    // give the scope name
    public String getScopeName() {
    	return this.getName();
    }

    // am I nested in another?
    public Scope getEnclosingScope() {
        return this.parent;

    }
  
    // give the root symbol of the scope
     public Symbol getScopeSymbol() {
    	return super.getSymbol();
    }

    public List getMembers() {
        return this.scope.getMembers();
    }
    
    // colecta as linhas do vuln path
    public Vulner collectVulnPathCodeInj(String dataInc, List UserInput, TaintedTable mts_princ, SymbolTable st, Boolean insideUserFunction, Map MainLinesToCorrect) {         
        ListVulners lv;
        Symbol symbolOfInput = null;
        int linhaScope = this.getScopeSymbol().getCodeLine();
        String fileScope = this.getScopeSymbol().getFileSymbol();
        String nameScope = this.getScopeSymbol().getName();        
              
        // Se vulnerabilidade numa TaintedFunction
        if (dataInc.equals("taintedFunction") == true){
            Scope scp = (Scope) this.scope;
            for (int i=1; i <= scp.getMembers().size() - 1; i++){
                scp.getMembers().remove(1);
            }
            dataInc = scp.resolveVarInclude(scp, st);           
            VulnerabilityPathCodeInj sc = new VulnerabilityPathCodeInj(scp);
            symbolOfInput = sc.getSymbolOfInput(st);            
        }
        else
            symbolOfInput = this.getSymbolOfInput(st);            

        String found = GlobalDataCodeInj.containsInput(dataInc);
        int indexInput = dataInc.indexOf("$" + found + "[");
        int lineOfInput = symbolOfInput.getCodeLine();
        String nameOfInput = symbolOfInput.getName(); //ja em $_GET['name']
        
        // Criar estrutura para armazenar as vulnerabilidades encontradas
        if (GlobalDataCodeInj.MainListVulners.containsKey(fileScope) == false){
            lv = new ListVulners(fileScope);
            GlobalDataCodeInj.MainListVulners.put(fileScope, lv);
        }
        else
            lv = GlobalDataCodeInj.MainListVulners.get(fileScope);
        
        // Adicionar a linha da vulnerabilidade
        String typeVul = GlobalDataCodeInj.getTypeVulInjection(nameScope);        
        Vulner vul = new Vulner(linhaScope, fileScope, false, typeVul);
        lv.getListOfVulners().add(vul);
        GlobalDataCodeInj.currentVulner = vul;

        if (GlobalDataCodeInj.currentVulner.getLineToSanitize() < 0){
            GlobalDataCodeInj.currentVulner.setLineToSanitize(linhaScope);
            GlobalDataCodeInj.currentVulner.setFileOfLineToSanitize(fileScope);
        }        
        
        
        try{
            // Rastrear os input tainted
            this.trackVuln("", false, mts_princ, st);

            // Correcao: buscar linha do ficheiro e colocar em array as linhas de correcao
            String codeLine="";
            ManageFiles fff = new ManageFiles (fileScope);
            codeLine = fff.getLineOfCode(linhaScope);
            LinesToCorrect ltc = getLinesToCorrect(fileScope, MainLinesToCorrect);
 
            String func = "", l1="", l2 = "";
            if (GlobalDataCodeInj.RFIFunctions.contains(nameScope) == true){
                String baseDir = System.getProperty("baseDir");
                if (baseDir != null)
                    func = "san_mix(" + nameOfInput + ", '" + nameScope + "', '" + baseDir + "')";
                else
                    func = "san_mix(" + nameOfInput + ", '" + nameScope + "', " + null + ")";
                
                l1 = "if (" + func + " == 0)";
                l2 = codeLine;
                
            }
            else{
                if (GlobalDataCodeInj.OSFunctions.contains(nameScope) == true){
                    func = "san_osci(" + nameOfInput + ")";
                    l1 = "if (" + func + " == 0)";
                    l2 = codeLine;
                }
                else{
                    func = "san_eval(" + nameOfInput + ", '" + codeLine.substring(0, codeLine.length()-1) + "')";
                    l1 = "if ( $san_line = " + func + " != 1)";
                    l2 = "$san_line;";
                }
            }

            String[] ar = {func, codeLine, nameScope, l1, l2};
            ltc.getMapLinesToCorrectArray().put(linhaScope, ar);        
                       
            GlobalDataCodeInj.currentVulner.setVulCode(codeLine);
            GlobalDataCodeInj.currentVulner.setCorrectedCode(func);
            
        } catch (Exception e){}        
        
        
        return GlobalDataCodeInj.currentVulner;
    }

    private Symbol getSymbolOfInput(SymbolTable st){
        Symbol sym, sy = null;
        String ss, s;
        Scope scp_aux;
        try{
        for(Iterator <Symbol> it = this.getMembers().iterator();it.hasNext(); ){
            sym = it.next();         
            if (sym.getRootScope() != null && sym.getAlfanumeric() == false){
                scp_aux = (Scope) sym;
                VulnerabilityPathCodeInj sc = new VulnerabilityPathCodeInj(scp_aux);
                sy = sc.getSymbolOfInput(st);                
            }
            else{
                String found = GlobalDataCodeInj.containsInput(sym.getName());
                if (found.isEmpty() == false)
                    return sym;

                if (sym.getAlfanumeric() == false){
                    ss = sym.getName();
                    for(Iterator <Symbol> it1 = st.getMembers().iterator();it1.hasNext(); ){
                        sym = it1.next();
                        s = sym.getName();
                        if (s.equals(ss) == true){
                            int i = st.getMembers().indexOf(sym);
                            scp_aux = (Scope) st.getMembers().get(i);
                            VulnerabilityPathCodeInj sc = new VulnerabilityPathCodeInj(scp_aux);
                            sy = sc.getSymbolOfInput(st);
                            break;
                        } 
                    }
                }
            }
	}
        } catch (Exception e){}
        return sy;
    }    
    
 
    private void trackVuln(String codeLine, Boolean moveUP, TaintedTable mts_princ, SymbolTable st){
        //Scope scp = this;
        VulnerabilityPathCodeInj scp = this;
        Iterator <Symbol> it;
        //String s = "", stmt="", concatenation="";

        for (it = scp.getMembers().iterator(); it.hasNext();){
            Symbol sym = it.next();
            if (sym.getRootScope() == null){
                if (sym.getTainted() == 1 && !sym.getAlfanumeric()){ // sym is $_GET or $var
                    Boolean iHaveFound = false;
                    String ui= "";
                    Iterator <String> it1 = GlobalDataCodeInj.UserInput.listIterator();
                    for (;it1.hasNext();){
                        ui = it1.next();
                        if (sym.getName().contains(ui) && sym.getName().startsWith("$"+ui+"[")){
                            iHaveFound = true;
                            break;
                        }
                    }
                    if (iHaveFound == true){
                        if (sym.getFileSymbol().equals(scp.getScopeSymbol().getFileSymbol()) == false)
                            GlobalDataCodeInj.currentVulner.setLineOfVulner(sym.getCodeLine(), sym.getFileSymbol());
                        else
                            if (sym.getCodeLine() != scp.getScopeSymbol().getCodeLine())
                                GlobalDataCodeInj.currentVulner.setLineOfVulner(sym.getCodeLine(), sym.getFileSymbol());
                        

                            // collect attributes to DM                            
                            GlobalDataCodeInj.currentVulner.setTaintedInputElements(sym.getCodeLine(), sym.getFileSymbol(), sym.getName());
                            String cod;
                            if (codeLine != "")
                                cod = codeLine;
                            else{
                                ManageFiles fff = new ManageFiles (sym.getFileSymbol());
                                cod = fff.getLineOfCode(sym.getCodeLine());                            
                            }
                            GlobalDataCodeInj.currentVulner.getVectorAttributesOfVulner().collectAttributes(cod, sym.getCodeLine(), sym.getFileSymbol(), true, GlobalDataCodeInj.currentVulner);                         
                        
                    }
                    else{ // $a, $var...
                        if (sym.getIsVariableSymbol()){
                            trackVulnVariable(sym, true, mts_princ, st);
                        
                            // collect attributes to DM                            
                            GlobalDataCodeInj.currentVulner.setTaintedInputElements(sym.getCodeLine(), sym.getFileSymbol(), "$" + sym.getName());
                            String cod;
                            if (codeLine != "")
                                cod = codeLine;
                            else{
                                ManageFiles fff = new ManageFiles (sym.getFileSymbol());
                                cod = fff.getLineOfCode(sym.getCodeLine());                            
                            }
                            GlobalDataCodeInj.currentVulner.getVectorAttributesOfVulner().collectAttributes(cod, sym.getCodeLine(), sym.getFileSymbol(), true, GlobalDataCodeInj.currentVulner);                        
                        } 
                   }
                }
            }
            else{
                // chamada de funcao definida pelo utilizador
                TaintedTable mts_aux = getMtsUserFunction(st, sym);

                if (sym.getIsFunction() == true && mts_aux != null)
                    trackVulnVariable(sym, true, mts_aux, st);
                else{
                    Scope scp11 = (Scope)sym.getRootScope();
                    VulnerabilityPathCodeInj scp1 = new VulnerabilityPathCodeInj(scp11);
                    scp1.trackVuln("", moveUP, mts_princ, st);
                }
            }
        }
    }    
    
    
   private void trackVulnVariable(Symbol sym, Boolean moveUP, TaintedTable mts_princ, SymbolTable st){    
       String stmt = "";
       int i, j, indiceScopeSymbol;
       RootTaintedSymbol Rrt;
       RelatedTaintedSymbol rtt;
       VariableTaintedSymbol vts;
       VulnerabilityPathCodeInj scp = null;
       TaintedTable mts_aux;
       SymbolTable st_aux = null;
       ArrayList listaIndiceLineTainted =new ArrayList(); // lista que armazena os indices das linhas das vars de include em st
       
       indiceScopeSymbol = sym.getScope().getScopeSymbol().getCodeLine(); // linha onde encontrou a var
       String nameScopeSymbol;
       
       if (sym.getIsFunction() == true)
            nameScopeSymbol = sym.getName();
       else
            nameScopeSymbol = sym.getScope().getScopeName(); // nome do scope
       
       LineAndFileRrt lf = new LineAndFileRrt();
       Integer linhaRrt;
       String fileRrt = "";
       boolean foundlf;
       mts_aux = mts_princ;

       foundlf = lf.foundLineAndFileRrt(sym, nameScopeSymbol, indiceScopeSymbol, mts_aux);
       if (foundlf == false){
            if (GlobalDataCodeInj.MainTaintedTable.containsKey(sym.getFileSymbol()) == true){
                mts_aux = GlobalDataCodeInj.MainTaintedTable.get(sym.getFileSymbol());
                foundlf = lf.foundLineAndFileRrt(sym, nameScopeSymbol, indiceScopeSymbol, mts_aux);
            }
            if (foundlf == false){
                if (GlobalDataCodeInj.MainFunctionsTaintedTable.containsKey(sym.getFileSymbol()) == true){
                    MethodTaintedTable mtt = GlobalDataCodeInj.MainFunctionsTaintedTable.get(sym.getFileSymbol());
                    Iterator <MethodSymbolTainted> it;
                    for(it = mtt.getListTaintedMembers().iterator(); it.hasNext();){
                        MethodSymbolTainted mstt = it.next();
                        mts_aux = mstt.getFunctionTaintedTable();
                        foundlf = lf.foundLineAndFileRrt(sym, nameScopeSymbol, indiceScopeSymbol, mts_aux);
                        if (foundlf == true)
                            break;
                    }
                }
            }
       }

      linhaRrt = lf.getLinhaRrt();
      fileRrt = lf.getFileRrt();
        // Obter Symbol Table
        boolean founded = false;
        
        // 1. Ver na st actual
        try{
        if (GlobalDataCodeInj.MainSymbolTable.containsKey(fileRrt) == true){
            st_aux = GlobalDataCodeInj.MainSymbolTable.get(fileRrt);

            // verificar se a linhaRrt e symName fazem parte deste st
            // Poderá ser uma linha de uma UserFunction. Caso não esteja em em staux ver nos st's das fucnçoes
            founded = false;
            Scope scpp;
            Symbol sy;
            for (Iterator <Symbol> it = st_aux.getMembers().iterator(); it.hasNext(); ){
                sy = it.next();
                if (sy.getIsVariableSymbol() == false){
                    scpp = (Scope) sy;
                    if (scpp.getScopeSymbol().getName().equals(sym.getName()) && scpp.getScopeSymbol().getCodeLine() == linhaRrt){
                    scp = new VulnerabilityPathCodeInj(scpp);
                    founded = true;
                    break;
                }
                }
            }
        }
        } catch (Exception e) {}
        
        // 2. Ver nos include files
        try{
        if(founded == false){
            if (GlobalDataCodeInj.MainIncludeFilesTable.containsKey(fileRrt) == true){
                st_aux = GlobalDataCodeInj.MainIncludeFilesTable.get(fileRrt);

                // verificar se a linhaRrt e symName fazem parte deste st
                // Poderá ser uma linha de uma UserFunction. Caso não esteja em em staux ver nos st's das fucnçoes
                founded = false;
                for (Iterator <Symbol> it = st_aux.getMembers().iterator(); it.hasNext(); ){
                    Scope sy = (Scope) it.next();
                    if (sy.getScopeSymbol().getName().equals(sym.getName()) && sy.getScopeSymbol().getCodeLine() == linhaRrt){
                        scp = new VulnerabilityPathCodeInj(sy);
                        founded = true;
                        break;
                    }
                }


            }
       }
       } catch (Exception e) {}

       String n = null;
       if (sym.getIsFunction() == true)
           n = "return";
       else
           n = sym.getName();
                   
       // 3. caso seja uma UserFunction
       try{
       if (founded == false){
            MethodTableCalls mtc = GlobalDataCodeInj.MainFunctionsCallsTable.get(fileRrt);
            for (Iterator <MethodSymbolCall> it = mtc.getListMethodsMembers().iterator(); it.hasNext(); ){
                MethodSymbolCall msc = it.next();
                founded = false;
                for (Iterator <Symbol> it1 = msc.getCallFunctionSymbols().iterator(); it1.hasNext(); ){
                    Scope sy = (Scope) it1.next();
                    if (sy.getScopeSymbol().getName().equals(n) && sy.getScopeSymbol().getCodeLine() == linhaRrt){
                        scp = new VulnerabilityPathCodeInj(sy);
                        founded = true;
                        st_aux = new SymbolTable(fileRrt);
                        st_aux.setAllSymbols(msc.getCallFunctionSymbols());
                        break;
                    }
                }
            }
         }
         } catch (Exception e) {}
        
        try{
        Scope scpp;
        Symbol sy;
        for (Iterator <Symbol> it = st_aux.getMembers().iterator(); it.hasNext(); ){
            sy = it.next();
            if (sy.getIsVariableSymbol() == false){
                scpp = (Scope) sy;
                if (scpp.getScopeSymbol().getName().equals(n) && scpp.getScopeSymbol().getCodeLine() == linhaRrt){
                    scp = new VulnerabilityPathCodeInj(scpp);
                    break;
                }
            }
        }
        // buscar linha do ficheiro
        String codeLine="";
        String file = scp.getScopeSymbol().getFileSymbol();
        ManageFiles fff = new ManageFiles (fileRrt);
        codeLine = fff.getLineOfCode(scp.getScopeSymbol().getCodeLine());

        // inserir codeLine como linha da vulner corrente
        GlobalDataCodeInj.currentVulner.setLineOfVulner(scp.getScopeSymbol().getCodeLine(), fileRrt);
        scp.trackVuln(codeLine, true, mts_aux, st_aux);
        } catch (Exception e) {}
   }    
    

    private LinesToCorrect getLinesToCorrect(String filename, Map MainLinesToCorrect){
        if (MainLinesToCorrect.containsKey(filename))
            return (LinesToCorrect) MainLinesToCorrect.get(filename);
        else{
            LinesToCorrect l = new LinesToCorrect(filename, true);
            MainLinesToCorrect.put(filename, l);
            return l;
        }
    }   
   
    // Tell if the symbol is a define user function
    public TaintedTable getMtsUserFunction(SymbolTable st, Symbol sym) {
        TaintedTable mts_aux = null;
        Iterator <MethodSymbolTainted> it;        
        if (st.getHaveFunctions()){
            MethodTaintedTable mtt = GlobalDataSqli.MainFunctionsTaintedTable.get(sym.getFileSymbol());
            for(it = mtt.getListTaintedMembers().iterator(); it.hasNext();){
                MethodSymbolTainted mstt = it.next();
                if (mstt.getFunctionNameCall().equals(sym.getName()) && mstt.getLineNumberCall() == sym.getCodeLine()){
                    mts_aux = mstt.getFunctionTaintedTable();
                    return mts_aux;
                }
            }
        }

        if (st.getIncludeFiles().size() > 0){           
            Iterator <String> it1;
            SymbolTable st_inc;
            String name_st_inc;
            for(it1 = st.getIncludeFiles().iterator(); it1.hasNext();){
                name_st_inc = it1.next();
                st_inc = GlobalDataSqli.MainIncludeFilesTable.get(name_st_inc);
                if (st_inc.getHaveFunctions()){
                    MethodTaintedTable mtt = GlobalDataSqli.MainFunctionsTaintedTable.get(st.getScopeName());
                    for(it = mtt.getListTaintedMembers().iterator(); it.hasNext();){                
                        MethodSymbolTainted mstt = it.next();
                        if (mstt.getFunctionNameCall().equals(sym.getName()) && mstt.getLineNumberCall() == sym.getCodeLine()){                           
                            mts_aux = mstt.getFunctionTaintedTable();                           
                            return mts_aux;
                        }
                    }
                }
            }
        }
        return mts_aux;
    }

    public void define(Symbol sym, Scope scp, Boolean IsVariableSymbol) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public Boolean resolve(Symbol symb, TaintedTable mts, UntaintedTable mus) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public void resolveSymbol(Scope scp, Symbol sy, TaintedTable mts, UntaintedTable mus, String file) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public void resolveSymbolInclude(Scope scp1, TaintedTable mts, UntaintedTable mus) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public String resolveVarInclude(Scope scp, SymbolTable st) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public void print(Scope scp) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    //public void resolveSymbolFunction(MethodSymbol mt, Scope rootScope, TaintedTable mts, UntaintedTable mus, Map mift, String filename, Map mft, Map mst, int vulns, Map varsDB, LinesToCorrect MapLinesToCorrect, Map MainLinesToCorrect) {
    public void resolveSymbolFunctionSQLI(MethodSymbol mt, Scope rootScope, TaintedTable mts, UntaintedTable mus, Map mift, String filename, Map mft, Map mst, Map varsDB, Map mftt, Map MainLinesToCorrect) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public void resolveSymbolIncludeSQLI(Scope scp, TaintedTable mts, UntaintedTable mus, Map mift, String filename, Map mft, Map mst, Map varsDB, Map mftt, Map MainLinesToCorrect) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public Boolean verifyNumberVarList(int num_var){
        throw new UnsupportedOperationException("Not supported yet.");    
    }
    
    public void populateList(Scope scp_left, Scope scp_right, int num_var, TaintedTable mts, UntaintedTable mus, String filename){
        throw new UnsupportedOperationException("Not supported yet.");    
    }    
    
    public Boolean buildCorrectCodeInj(String fileInc, List UserInput, TaintedTable mts_princ, SymbolTable st, Map MainLinesToCorrect){
            throw new UnsupportedOperationException("Not supported yet.");
    }
    
    public Boolean buildCorrectXSS(String fileInc, List UserInput, TaintedTable mts_princ, SymbolTable st, Map MainLinesToCorrect){
            throw new UnsupportedOperationException("Not supported yet.");
    }

    public void resolveSymbolClass(TaintedTable mts, UntaintedTable mus, String filename) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

        public void printtt(String string, Scope cp){
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public void resolveSymbolParam(TaintedTable mts, UntaintedTable mus, String filename) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    public void resolveParam(Symbol symb, TaintedTable mts, UntaintedTable mus) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    public String buildCorrectSQL(String connDB, String nameDB, int lineMysqliBindParam, List UserInput, TaintedTable mts_princ, SymbolTable st, Map MainLinesToCorrect) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    public void copyScope(Scope src, Scope dest) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }
}
