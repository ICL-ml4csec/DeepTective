/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.homeunix.wap.XSS;

import org.homeunix.wap.table.tainted.*;
import org.homeunix.wap.table.symbol.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.*;
import java.lang.reflect.*;
import org.homeunix.wap.utils.*;


/**
 *
 * @author iberiam
 */
public class VulnerabilityPathXSS extends Symbol implements Scope{
    Scope scope;
    Scope parent;
    
    // *** CONSTRUCTOR
    public VulnerabilityPathXSS(Scope scp) {
        super(scp.getScopeSymbol().getName(), scp.getScopeSymbol().getTainted(), scp.getScopeSymbol().getCodeLine(), scp.getScopeSymbol().getFileSymbol());
        this.scope = scp;
        this.parent = scp.getEnclosingScope();
    }

    // *** METHODS

    // give the scope name
    public String getScopeName() {
    	return this.getName();
    }

    // am I nested in another?
    public Scope getEnclosingScope() {
        return this.parent;

    }
  
    // give the root symbol of the scope
     public Symbol getScopeSymbol() {
    	return super.getSymbol();
    }

    public List getMembers() {
        return this.scope.getMembers();
    }
    
    // colecta as linhas do vuln path
    public VulnerXSS collectVulnPathXSS(List UserInput, TaintedTable mts_princ, SymbolTable st, Boolean insideUserFunction, Map MainLinesToCorrect) {    
        String xss_final="", xssFunc;
        int linhaScope = this.getScopeSymbol().getCodeLine();
        String fileScope = this.getScopeSymbol().getFileSymbol();
        ListVulners lv;
        
        int indiceXSSFunc = 0;
        /*
         * indiceXSSFunc value
         * 0 - encodeOutput - san_out
         * 1 - putStoreData - san_wdata
         * 2 - getStoreData - san_rdata
         */  
              

        // Criar estrutura para armazenar as vulnerabilidades encontradas
        if (GlobalDataXSS.MainListVulners.containsKey(fileScope) == false){
            lv = new ListVulners(fileScope);
            GlobalDataXSS.MainListVulners.put(fileScope, lv);
        }
        else
            lv = GlobalDataXSS.MainListVulners.get(fileScope);

        xssFunc = this.getScopeName();
        
        // Adicionar a linha da vulnerabilidade
        VulnerXSS vul = new VulnerXSS(linhaScope, fileScope, xssFunc);
                
        if (xssFunc.equals("file_put_contents") || xssFunc.equals("fprintf"))
            indiceXSSFunc = 1;
        else
            if (xssFunc.equals("file_get_contents") || xssFunc.equals("fgets") || xssFunc.equals("fgetc") || xssFunc.equals("fscanf"))
                indiceXSSFunc = 2;
            else
                indiceXSSFunc = 0;
        
        // Vuscar a linhs vlneravel
        ManageFiles fff = new ManageFiles (fileScope);
        String codeLine = fff.getLineOfCode(linhaScope);
        
        vul.setIndiceXSSEscapeFunc(indiceXSSFunc);

        
        lv.getListOfVulners().add(vul);
        GlobalDataXSS.currentVulner = vul;

        try{
            xss_final = this.collectStmt(this, "", indiceXSSFunc, false, UserInput, mts_princ, st, MainLinesToCorrect, xssFunc);       
        } catch (Exception e){}
               
        return GlobalDataXSS.currentVulner;
    }

    
    public String collectStmt(VulnerabilityPathXSS sc, String codeLine, int indiceXSSFunc, Boolean moveUP, List UserInput, TaintedTable mts_princ, SymbolTable st, Map MainLinesToCorrect, String xssFunc){    
        VulnerabilityPathXSS scp = this;
        Iterator <Symbol> it;
        String s = "", stmt="", concatenation="", builAntiXSSFunc = "", antiXSSFunc = "";


        for (it = scp.getMembers().iterator(); it.hasNext();){
            Symbol sym = it.next();
            if (sym.getAlfanumeric())               
                sym.setNameMultiline();            
            
            if (sym.getRootScope() == null){
                if (sym.getTainted() == 1){    
                    if (sym.getAlfanumeric() == true){
                        
                        if (GlobalDataXSS.currentVulner.getLineToSanitize() < 0){
                            GlobalDataXSS.currentVulner.setLineToSanitize(sym.getCodeLine());
                            GlobalDataXSS.currentVulner.setFileOfLineToSanitize(sym.getFileSymbol());
                            GlobalDataXSS.currentVulner.setVulCode(sym.getName());
                        }
                        
                        
                        antiXSSFunc = getAntiXSSFunction(indiceXSSFunc);
                        try{
                            // procurar posicoes para a correcao, o resto do vv path e os atributos dm
                            stmt = collectStmtAlphanumeric(sym, UserInput, antiXSSFunc, mts_princ, indiceXSSFunc, st, MainLinesToCorrect, xssFunc);
                        } catch (Exception e){}
                        
                        // collect attributes to DM
                        String cod;
                        if (codeLine != "")
                            cod = codeLine;
                        else{
                            ManageFiles fff = new ManageFiles (sym.getFileSymbol());
                            cod = fff.getLineOfCode(sym.getCodeLine());                            
                        }
                        GlobalDataXSS.currentVulner.getVectorAttributesOfVulner().collectAttributes(cod, sym.getCodeLine(), sym.getFileSymbol(), true, GlobalDataXSS.currentVulner);

                    }
                    else{// sym is a entry point or a var
                        Boolean iHaveFound = false;
                        String ui;
                        Iterator <String> it1 = UserInput.listIterator();
                        for (;it1.hasNext();){
                            ui = it1.next();
                            if (sym.getName().contains(ui) && sym.getName().startsWith("$"+ui+"[")){
                                iHaveFound = true;
                                break;
                            }
                        }
                        
                        // $_POST, ...
                        if (iHaveFound == true){
                            if (sym.getCodeLine() == GlobalDataXSS.currentVulner.getLineToSanitize()
                                && GlobalDataXSS.currentVulner.getIndiceXSSEscapeFunc() > -1){
                                
                                String f = GlobalDataXSS.currentVulner.getCorrectedCode();
                                
                                builAntiXSSFunc = getBuildAntiXSSFunction(indiceXSSFunc); 
                                Method method=null;
                                VulnerabilityPathXSS scpsym = (VulnerabilityPathXSS) sc;
                            try {
                                method = scpsym.getClass().getMethod(builAntiXSSFunc, Symbol.class);
                            } catch (NoSuchMethodException ex) {
                                Logger.getLogger(VulnerabilityPathXSS.class.getName()).log(Level.SEVERE, null, ex);
                            } catch (SecurityException ex) {
                                Logger.getLogger(VulnerabilityPathXSS.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            try {
                                s = (String) method.invoke(scpsym, sym);
                            } catch (IllegalAccessException ex) {
                                Logger.getLogger(VulnerabilityPathXSS.class.getName()).log(Level.SEVERE, null, ex);
                            } catch (IllegalArgumentException ex) {
                                Logger.getLogger(VulnerabilityPathXSS.class.getName()).log(Level.SEVERE, null, ex);
                            } catch (InvocationTargetException ex) {
                                Logger.getLogger(VulnerabilityPathXSS.class.getName()).log(Level.SEVERE, null, ex);
                            }                                
                              
                            
                            f = f.replace(sym.getName(), s);
                            if (f != "")
                                GlobalDataXSS.currentVulner.setCorrectedCode(f);
                            stmt = f;
                            }
                            
                            // collect attributes to DM                            
                            GlobalDataXSS.currentVulner.setTaintedInputElements(sym.getCodeLine(), sym.getFileSymbol(), sym.getName());
                            String cod;
                            if (codeLine != "")
                                cod = codeLine;
                            else{
                                ManageFiles fff = new ManageFiles (sym.getFileSymbol());
                                cod = fff.getLineOfCode(sym.getCodeLine());                            
                            }
                            GlobalDataXSS.currentVulner.getVectorAttributesOfVulner().collectAttributes(cod, sym.getCodeLine(), sym.getFileSymbol(), true, GlobalDataXSS.currentVulner);                            
                            
                            
                                if(codeLine.isEmpty() == true && sym.getScope().getScopeName().equals("concatenation")){
                                    ManageFiles fff = new ManageFiles (sym.getFileSymbol());
                                    codeLine = fff.getLineOfCode(sym.getCodeLine());
                                }

                        }
                        else{ // $a, $var...
                            if (sym.getIsVariableSymbol()){
                                if (sym.getCodeLine() == GlobalDataXSS.currentVulner.getLineToSanitize()
                                    && GlobalDataXSS.currentVulner.getIndiceXSSEscapeFunc() > -1){
                                    
                                    String f = GlobalDataXSS.currentVulner.getCorrectedCode();

                                        builAntiXSSFunc = getBuildAntiXSSFunction(indiceXSSFunc); 
                                        Method method=null;
                                        VulnerabilityPathXSS scpsym = (VulnerabilityPathXSS) sc;
                                    try {
                                        method = scpsym.getClass().getMethod(builAntiXSSFunc, Symbol.class);
                                    } catch (NoSuchMethodException ex) {
                                        Logger.getLogger(VulnerabilityPathXSS.class.getName()).log(Level.SEVERE, null, ex);
                                    } catch (SecurityException ex) {
                                        Logger.getLogger(VulnerabilityPathXSS.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                    try {
                                        s = (String) method.invoke(scpsym, sym);
                                    } catch (IllegalAccessException ex) {
                                        Logger.getLogger(VulnerabilityPathXSS.class.getName()).log(Level.SEVERE, null, ex);
                                    } catch (IllegalArgumentException ex) {
                                        Logger.getLogger(VulnerabilityPathXSS.class.getName()).log(Level.SEVERE, null, ex);
                                    } catch (InvocationTargetException ex) {
                                        Logger.getLogger(VulnerabilityPathXSS.class.getName()).log(Level.SEVERE, null, ex);
                                    }                                    
                                                                      
                                    f = f.replace("$"+sym.getName(), s);
                                    if (f.equals("") == false)
                                        GlobalDataXSS.currentVulner.setCorrectedCode(f);
                                    stmt = f;
                                }
                                
                                try{
                                    String s3 = collectStmtVariable(indiceXSSFunc, sym, true, UserInput, mts_princ, st, MainLinesToCorrect, xssFunc);
                                } catch (Exception e){}
                                
                                // collect attributes to DM                            
                                GlobalDataXSS.currentVulner.setTaintedInputElements(sym.getCodeLine(), sym.getFileSymbol(), "$" + sym.getName());
                                String cod;
                                if (codeLine != "")
                                    cod = codeLine;
                                else{
                                    ManageFiles fff = new ManageFiles (sym.getFileSymbol());
                                    cod = fff.getLineOfCode(sym.getCodeLine());                            
                                }
                                GlobalDataXSS.currentVulner.getVectorAttributesOfVulner().collectAttributes(cod, sym.getCodeLine(), sym.getFileSymbol(), true, GlobalDataXSS.currentVulner);
                            }  
                        }
                    }
                }
                else{
                    // Se for alfanumerico, nao tainted
                    if (sym.getAlfanumeric() == true){
                        if (GlobalDataXSS.currentVulner.getLineToSanitize() < 0){
                            GlobalDataXSS.currentVulner.setLineToSanitize(sym.getCodeLine());
                            GlobalDataXSS.currentVulner.setFileOfLineToSanitize(sym.getFileSymbol());
                            ManageFiles fff = new ManageFiles (sym.getFileSymbol());
                            codeLine = fff.getLineOfCode(sym.getCodeLine());                                    
                            GlobalDataXSS.currentVulner.setVulCode(codeLine);
                            GlobalDataXSS.currentVulner.setCorrectedCode(codeLine);
                            stmt = codeLine;
                        }
                    }                
                }
            }
            else{
                    // chamada de funcao definida pelo utilizador
                    TaintedTable mts_aux = null;                     
                    try{
                        mts_aux = getMtsUserFunction(st, sym);
                    } catch (Exception e){}

                    if (sym.getIsFunction() == true && mts_aux != null){
                        stmt = collectStmtVariable(indiceXSSFunc, sym, true, UserInput, mts_aux, st, MainLinesToCorrect, xssFunc);
                    }
                    else{
                        Scope scp11 = (Scope)sym.getRootScope();
                        VulnerabilityPathXSS scp1 = new VulnerabilityPathXSS(scp11);
                        try{
                            stmt = scp1.collectStmt(sc, "", indiceXSSFunc, moveUP, UserInput, mts_princ, st, MainLinesToCorrect, xssFunc);
                        }catch (Exception e){}
                    }
            }      
        }
        
        return stmt;
    }    
    
    private String collectStmtAlphanumeric(Symbol sym, List UserInput, String antiXSSFunc, TaintedTable mts_princ, int indiceXSSFunc, SymbolTable st, Map MainLinesToCorrect, String xssFunc){            
        String final_str="\"", a = "", aa, leftside_a, rest_a, userinput = "", antiXSSString = "", aux;
        String final_str_aux;
        int indice_input, open_square_brace, j=0, indice_var = 0;
        Iterator <RootTaintedSymbol> it1;
        RootTaintedSymbol raux;
        char chars[];
        ArrayList lista =new ArrayList(); // array que armazena os indices onde aparecem os UserInput ($_POST...)
        ArrayList lista_len =new ArrayList(); // array que armazena os tamanhos onde aparecem os UserInput ($_POST...)
        Boolean foundVar = false;
        
        if (sym.getCodeLine() == GlobalDataXSS.currentVulner.getLineToSanitize()
                && GlobalDataXSS.currentVulner.getIndiceXSSEscapeFunc() > -1){
            
            // Procura os indices dos UserInput na string em analise
            Iterator <String> it = UserInput.listIterator();
            for (;it.hasNext();){
                aux = it.next();
                indice_input = 0; // index do input encontrado na string em analise
                a = sym.getName(); 
                while (a.contains("$"+aux+"[") == true){
                    lista.add(a.indexOf(aux) + indice_input - 1);
                    indice_input = indice_input + a.indexOf(aux) + aux.length();
                    a = a.substring(a.indexOf(aux) + aux.length());
                }
            }
            Collections.sort(lista);
        
            if (lista.size() > 0){
                GlobalDataXSS.currentVulner.getPositionSanFunction().addAll(lista);
        
                // Obter o tamanho dos user inputs
                indice_input = 0;
                a = sym.getName();
                for(int i=0; i < lista.size(); i++){
                    //userinput="$";
                    leftside_a = a.substring(1, (Integer)lista.get(i)-indice_input-j-1);
                    //aa = a.substring(1, (Integer)lista.get(i)-indice_input-j-3);
                    rest_a = a.substring((Integer)lista.get(i)-indice_input-j);
                    indice_input = (Integer)lista.get(i);

                    j = 0;
                    chars = rest_a.toCharArray();
                    while (chars[j] != '[')
                        j++;

                    j++;
                    open_square_brace = 1;
                    while (open_square_brace != 0){
                        if (chars[j] == '[')
                            open_square_brace++;
                        if (chars[j] == ']')
                            open_square_brace--;
                        j++;
                    }
                    
                    lista_len.add(j);
                    
                    userinput = rest_a.substring(0, j);
                    a = rest_a.substring(j);

                    GlobalDataXSS.currentVulner.setTaintedInputElements(sym.getCodeLine(), sym.getFileSymbol(), userinput);

                    antiXSSString = antiXSSFunc + "(" + userinput + ")";
                    final_str = final_str + leftside_a + "\"." + antiXSSString + ".\"";
                }
                GlobalDataXSS.currentVulner.getLenghtSanFunction().addAll(lista_len);
            }

        
                if (a.startsWith("\'"))
                    a = a.substring(1, a.length());
                else
                    a = a.substring(0, a.length());
                
                final_str = final_str + a;
                a = final_str;

            if (a.equals(sym.getName()) == false && final_str != ""){
                GlobalDataXSS.currentVulner.setCorrectedCode(final_str);
            }
        }
     
        if (lista.isEmpty()){
            a = sym.getName();
            final_str = a;
        }        
        
        final_str_aux = a;
        
        // Procura os indices das Tainted vars na string em analise e faz correcao automatica
        it1 = mts_princ.getTaintedMembers().values().iterator();
        lista.clear();
        lista_len.clear();
        for (;it1.hasNext();){
            raux = it1.next();
            aux = raux.getName();
            
            indice_input = 0; // index do input encontrado na string em analise
            while (a.contains("$"+aux+"\'") == true || a.contains("$"+aux+"\"") == true || a.contains("$"+aux+" ") == true){
                if (a.contains("$"+aux+"\'"))
                    j = a.indexOf("$"+aux+"\'");
                else
                    if (a.contains("$"+aux+"\""))
                        j = a.indexOf("$"+aux+"\"");
                    else
                        j = a.indexOf("$"+aux+" ");
                
                
                lista.add(j + indice_input);
                indice_input = indice_input + j + aux.length();
                a = a.substring(j + aux.length()+1);
            }
            a = final_str;
        }
            Collections.sort(lista);
            
            if (sym.getCodeLine() == GlobalDataXSS.currentVulner.getLineToSanitize()
                    && GlobalDataXSS.currentVulner.getIndiceXSSEscapeFunc() > -1){ 
                
                if (lista.size() > 0){
                    foundVar = true;
                    GlobalDataXSS.currentVulner.getPositionSanFunction().addAll(lista);

                    // Obter o tamanho das vars
                    j = 0;
                    indice_input = 0;
                    a = final_str;
                    final_str = "\"";
                    for(int i=0; i < lista.size(); i++){
                        leftside_a = a.substring(1, (Integer)lista.get(i)-indice_input-j-1);
                        rest_a = a.substring((Integer)lista.get(i)-indice_input-j);
                        indice_input = (Integer)lista.get(i);

                        j = 0;
                        chars = rest_a.toCharArray();
                        while (chars[j] != '\'' && chars[j] != '\"' && chars[j] != ' ')
                            j++;

                        lista_len.add(j);

                        userinput = rest_a.substring(0, j);
                        a = rest_a.substring(j);

                        GlobalDataXSS.currentVulner.setTaintedInputElements(sym.getCodeLine(), sym.getFileSymbol(), userinput);                       
                        antiXSSString = antiXSSFunc + "(" + userinput + ")";
                        final_str = final_str + leftside_a + "\"." + antiXSSString + ".\"";
                    }            
                GlobalDataXSS.currentVulner.getLenghtSanFunction().addAll(lista_len);

                if (a.length() >= 1)
                    final_str = final_str + a;
                
                if (a.equals(sym.getName()) == false && final_str != ""){
                    GlobalDataXSS.currentVulner.setCorrectedCode(final_str);
                }
                }
        }
        
        if (foundVar == true){
            a = final_str_aux;
            it1 = mts_princ.getTaintedMembers().values().iterator();
            for (;it1.hasNext();){
                raux = it1.next();
                aux = raux.getName();
                for(int i=0; i < lista.size(); i++){
                    userinput = a.substring((Integer)lista.get(i)+1, (Integer)lista.get(i) + (Integer)lista_len.get(i));

                    if (userinput.equals(aux)){
                        Symbol symb = new Symbol(userinput, 1, sym.getCodeLine(), sym.getFileSymbol());
                        symb.setIsVariableSymbol(true);
                        symb.setScope(sym.getScope());
                        userinput = "$" + userinput;
                        try{
                            collectStmtVariable(indiceXSSFunc, symb, true, UserInput, mts_princ, st, MainLinesToCorrect, xssFunc);
                        }catch (Exception e){}
                        
                        // collect attributes to DM                            
                        GlobalDataXSS.currentVulner.setTaintedInputElements(sym.getCodeLine(), sym.getFileSymbol(), userinput);
                        String cod;
                        ManageFiles fff = new ManageFiles (sym.getFileSymbol());
                        cod = fff.getLineOfCode(sym.getCodeLine());                            
                        GlobalDataXSS.currentVulner.getVectorAttributesOfVulner().collectAttributes(cod, sym.getCodeLine(), sym.getFileSymbol(), true, GlobalDataXSS.currentVulner);                        
                    }
                }
            }
        }
        
        return final_str;
    }
    
   
   private String collectStmtVariable(int indiceXSSFunc, Symbol sym, Boolean moveUP, List UserInput, TaintedTable mts_princ, SymbolTable st, Map MainLinesToCorrect, String xssFunc) {      
       String stmt = "";
       int i, j, indiceScopeSymbol;
       RootTaintedSymbol Rrt;
       RelatedTaintedSymbol rtt;
       VariableTaintedSymbol vts;
       VulnerabilityPathXSS scp = null;
       TaintedTable mts_aux;
       SymbolTable st_aux = null;
       ArrayList listaIndiceLineTainted =new ArrayList(); // lista que armazena os indices das linhas das vars de mysql em st
       
       indiceScopeSymbol = sym.getScope().getScopeSymbol().getCodeLine(); // linha onde encontrou a var em mysql
       String nameScopeSymbol;
       
       if (sym.getIsFunction() == true)
            nameScopeSymbol = sym.getName();
       else
            nameScopeSymbol = sym.getScope().getScopeName(); // nome do scope em mysql
       
       LineAndFileRrt lf = new LineAndFileRrt();
       Integer linhaRrt;
       String fileRrt = "";
       boolean foundlf;
       mts_aux = mts_princ;
       foundlf = foundLineAndFileRrt(lf, sym, nameScopeSymbol, indiceScopeSymbol, mts_aux);
       if (foundlf == false){
            if (GlobalDataXSS.MainTaintedTable.containsKey(sym.getFileSymbol()) == true){
                mts_aux = GlobalDataXSS.MainTaintedTable.get(sym.getFileSymbol());
                foundlf = foundLineAndFileRrt(lf, sym, nameScopeSymbol, indiceScopeSymbol, mts_aux);
            }
            if (foundlf == false){
                if (GlobalDataXSS.MainFunctionsTaintedTable.containsKey(sym.getFileSymbol()) == true){
                    MethodTaintedTable mtt = GlobalDataXSS.MainFunctionsTaintedTable.get(sym.getFileSymbol());
                    Iterator <MethodSymbolTainted> it;
                    for(it = mtt.getListTaintedMembers().iterator(); it.hasNext();){
                        MethodSymbolTainted mstt = it.next();
                        mts_aux = mstt.getFunctionTaintedTable();
                        foundlf = foundLineAndFileRrt(lf, sym, nameScopeSymbol, indiceScopeSymbol, mts_aux);
                        if (foundlf == true)
                            break;
                    }
                }
            }
       }

          linhaRrt = lf.getLinhaRrt();
          fileRrt = lf.getFileRrt();         
          
            // Obter Symbol Table
           String n = "";
           if (sym.getIsFunction() == true)
               n = "return";
           else
               n = sym.getName();
          
          boolean found = false;

            //1. Ver na st actual
            try{
            st_aux = st;
            Symbol syy;
            for (Iterator <Symbol> it = st_aux.getMembers().iterator(); it.hasNext(); ){
                syy = it.next();
                if (syy.getIsVariableSymbol() == false){
                    Scope sy = (Scope) syy; 
                    if (sy.getScopeSymbol().getName().equals(n) && sy.getScopeSymbol().getCodeLine() == linhaRrt){
                        scp = new VulnerabilityPathXSS(sy);
                        found = true;
                        break;
                    }
                }
            }
            } catch (Exception e) {}

            // 2. Ver nas tabela dos outros files
            try{
            if(found == false){
                if (GlobalDataXSS.MainSymbolTable.containsKey(fileRrt) == true){
                    st_aux = GlobalDataXSS.MainSymbolTable.get(fileRrt);

                    // verificar se a linhaRrt e symName fazem parte deste st
                    // Poderá ser uma linha de uma UserFunction. Caso não esteja em em staux ver nos st's das fucnçoes
                    found = false;
                    for (Iterator <Symbol> it = st_aux.getMembers().iterator(); it.hasNext(); ){
                        Scope sy = (Scope) it.next();
                        if (sy.getScopeSymbol().getName().equals(sym.getName()) && sy.getScopeSymbol().getCodeLine() == linhaRrt){
                            scp = new VulnerabilityPathXSS(sy);
                            found = true;
                            break;
                        }
                    }
                    
                    for (Iterator <Symbol> it = st_aux.getMembers().iterator(); it.hasNext(); ){
                        Scope sy = (Scope) it.next();
                        if (sy.getScopeSymbol().getCodeLine() == linhaRrt){
                            // Procura Scope do sym
                            Scope sc = foundScope(sy, sym.getName());
                            scp = new VulnerabilityPathXSS(sc);
                            found = true;
                            break;
                        }
                    }             
                }
            }
            } catch (Exception e) {}

            // 3. ver nos includes files
            try{
            if(found == false){
                if (GlobalDataXSS.MainIncludeFilesTable.containsKey(fileRrt) == true){
                    st_aux = GlobalDataXSS.MainIncludeFilesTable.get(fileRrt);

                    // verificar se a linhaRrt e symName fazem parte deste st
                    // Poderá ser uma linha de uma UserFunction. Caso não esteja em em staux ver nos st's das fucnçoes
                    found = false;
                    for (Iterator <Symbol> it = st_aux.getMembers().iterator(); it.hasNext(); ){
                        Scope sy = (Scope) it.next();
                        if (sy.getScopeSymbol().getName().equals(sym.getName()) && sy.getScopeSymbol().getCodeLine() == linhaRrt){
                            scp = new VulnerabilityPathXSS(sy);
                            found = true;
                            break;
                        }
                    }
                    
                    for (Iterator <Symbol> it = st_aux.getMembers().iterator(); it.hasNext(); ){
                        Scope sy = (Scope) it.next();
                        if (sy.getScopeSymbol().getCodeLine() == linhaRrt){
                            // Procura Scope do sym
                            Scope sc = foundScope(sy, sym.getName());
                            scp = new VulnerabilityPathXSS(sc);
                            found = true;
                            break;
                        }
                    }             
                }
           }
            } catch (Exception e) {}            
                   
           // 4. ver em user functions
           try{
           if (found == false){
               String aa = fileRrt;
               // Aqui o fileRrt e' o nome da Userfunction que esta a ser analisada
               ManageFiles fff = new ManageFiles (fileRrt);
               if (fileRrt.equals(nameScopeSymbol) == false && fff.existFile(fileRrt) == false)
                    aa = sym.getFileSymbol();
                
               if (GlobalDataXSS.MainFunctionsCallsTable.containsKey(aa) == true){
                    MethodTableCalls mtc = GlobalDataXSS.MainFunctionsCallsTable.get(aa);
                    
                    for (Iterator <MethodSymbolCall> it = mtc.getListMethodsMembers().iterator(); it.hasNext(); ){
                        MethodSymbolCall msc = it.next();
                        found = false;
                        for (Iterator <Symbol> it1 = msc.getCallFunctionSymbols().iterator(); it1.hasNext(); ){
                            Scope sy = (Scope) it1.next();
                            if (sy.getScopeSymbol().getName().equals(n) && sy.getScopeSymbol().getCodeLine() == linhaRrt){
                                scp = new VulnerabilityPathXSS(sy);
                                found = true;
                                st_aux = new SymbolTable(aa);
                                st_aux.setAllSymbols(msc.getCallFunctionSymbols());
                                break;
                            }
                        }
                    }
                }
             }
            } catch (Exception e) {}           

           // 5. ver nos outros files de user functions (ultima hipotese)
           // quando uma user function chamada num file chama outra que pertence a outro file
           try{
           if (found == false){
               String aa = fileRrt;
               MethodTableCalls mtc;
               
               for (Iterator <MethodTableCalls> it2 = GlobalDataXSS.MainFunctionsCallsTable.values().iterator(); it2.hasNext(); ){
                   mtc = it2.next();
                   //if (mtc.getScopeName().equals(fileRrt) == false){                      
                        for (Iterator <MethodSymbolCall> it = mtc.getListMethodsMembers().iterator(); it.hasNext(); ){
                            MethodSymbolCall msc = it.next();
                            found = false;
                            for (Iterator <Symbol> it1 = msc.getCallFunctionSymbols().iterator(); it1.hasNext(); ){
                                Scope sy = (Scope) it1.next();
                                if (sy.getScopeSymbol().getName().equals(n) && sy.getScopeSymbol().getCodeLine() == linhaRrt){
                                    scp = new VulnerabilityPathXSS(sy);
                                    found = true;
                                    st_aux = new SymbolTable(msc.getFunctionNameCall());
                                    st_aux.setAllSymbols(msc.getCallFunctionSymbols());
                                    
                                    MethodTaintedTable mtt = GlobalDataXSS.MainFunctionsTaintedTable.get(mtc.getScopeName());                                    
                                    Iterator <MethodSymbolTainted> it3;
                                    for(it3 = mtt.getListTaintedMembers().iterator(); it3.hasNext();){
                                        MethodSymbolTainted mstt = it3.next();
                                        if (mstt.getFunctionNameCall().equals(msc.getFunctionNameCall()) == true){
                                            mts_aux = mstt.getFunctionTaintedTable();
                                            break;
                                        }
                                    }                                    
                                    break;
                                }
                            }
                            if (found == true)
                                break;                            
                        }  
                   //}
                    if (found == true)
                        break;
               }  
             }
            } catch (Exception e) {}           

                
                    try{ 
                    Scope scpp;
                    Symbol sy;
                    for (Iterator <Symbol> it = st_aux.getMembers().iterator(); it.hasNext(); ){
                        sy = it.next();
                        if (sy.getIsVariableSymbol() == false){
                            scpp = (Scope) sy;
                            if (scpp.getScopeSymbol().getName().equals(n) && scpp.getScopeSymbol().getCodeLine() == linhaRrt){
                                scp = new VulnerabilityPathXSS(scpp);
                                break;
                            }
                        }
                    }                   
                    
                    // buscar linha do ficheiro
                    String codeLine="";
                    ManageFiles fff = new ManageFiles (fileRrt);
                    codeLine = fff.getLineOfCode(scp.getScopeSymbol().getCodeLine());


                    // inserir codeLine como linha da vulner corrente
                    GlobalDataXSS.currentVulner.setLineOfVulner(scp.getScopeSymbol().getCodeLine(), fileRrt);
                    if (fileRrt.equals(mts_aux.getScopeTaintedName()) == false){
                        ManageFiles ff = new ManageFiles(fileRrt);
                        if (ff.existFile(fileRrt) == true){
                            try{
                                MethodTable mt = GlobalDataXSS.MainFunctionsTable.get(fileRrt);
                                found = false;
                                if (mt != null){
                                    Iterator <MethodSymbol> it = mt.getMembers().iterator();
                                    MethodSymbol ms;

                                    for (; it.hasNext();){
                                        ms = it.next();
                                        if (ms.getFunctionName().equals(mts_aux.getScopeTaintedName())){
                                            found = true;
                                            break;
                                        }
                                    }
                                }
                                if (found == false){
                                    mts_aux = GlobalDataXSS.MainTaintedTable.get(fileRrt);
                                    try{
                                        st_aux = GlobalDataXSS.MainSymbolTable.get(fileRrt);
                                    } catch (Exception e){
                                        st_aux = GlobalDataXSS.MainIncludeFilesTable.get(fileRrt);
                                    }
                                }
                            } catch (Exception e) {}
                        }
                    }
                           
                        
                    stmt = scp.collectStmt(scp, codeLine, indiceXSSFunc, true, UserInput, mts_aux, st_aux, MainLinesToCorrect, xssFunc);

                   } catch (Exception e) {}
                    
       return stmt;
   }
   
   private Boolean foundLineAndFileRrt(LineAndFileRrt lf, Symbol sym, String nameScopeSymbol, int indiceScopeSymbol, TaintedTable mts_aux){
       RootTaintedSymbol Rrt=null;
       RelatedTaintedSymbol rtt;
       VariableTaintedSymbol vts;
       int i, j;
       Integer linhaRrt;
       String fileRrt;
       
       if (sym.getIsFunction() == true){
           if (mts_aux.getTaintedMembers().containsKey("return"))
               Rrt = (RootTaintedSymbol) mts_aux.getTaintedMembers().get("return");
       }
       else{
           if (mts_aux.getTaintedMembers().containsKey(sym.getName()))
                Rrt = (RootTaintedSymbol) mts_aux.getTaintedMembers().get(sym.getName());
       }
       

       if(Rrt != null){
           for(i=0; i < Rrt.getLinesList().size(); i++){
                rtt = (RelatedTaintedSymbol) Rrt.getListTaintedMembers().get(i);
                if(rtt.getTaintedMembers().containsKey(nameScopeSymbol)){
                    vts = (VariableTaintedSymbol) rtt.getTaintedMembers().get(nameScopeSymbol);
                    if(vts.getVariableLines().contains(indiceScopeSymbol)){
                        // Analisar os membros do Scope

                        // remove duplicate indexes
                        for(j=0; j < Rrt.getLinesList().size()-1; j++){
                            if (Rrt.getLinesList().get(j) == Rrt.getLinesList().get(j+1)){
                                Rrt.getLinesList().remove(j+1);
                                j--;
                            }
                        }


                        linhaRrt = (Integer) Rrt.getLinesList().get(i);
                        fileRrt = (String) Rrt.getFilesList().get(i);
                        lf.setLinhaFileRrt(linhaRrt, fileRrt);
                        return true;
                    }
                }
           }
       }
       return false;
   }
   
   
   private Scope foundScope(Scope sy, String symName){
       Iterator <Symbol> it = sy.getMembers().iterator();
       Symbol syy;
       for (; it.hasNext();){
           syy = it.next();
           if (syy.getName().equals(symName) == true)
               return sy;
           else
               return foundScope((Scope)syy, symName);
       }
        return null;
   }
   
  
private String correctXSS(String file, String codeLine, String xssFunc, String xss_final, Map mlc){
       String ss = "", aux="";
       char chars[];

       if (xssFunc.equals("echo") || xssFunc.equals("print")){
           ss = ss + xssFunc + " " + xss_final + ";";
       }
       
       if (xssFunc.equals("printf") || xssFunc.equals("file_put_contents") || xssFunc.equals("file_get_contents")){
           int i = codeLine.indexOf(xssFunc);
           if (i==0)
               aux = xssFunc;
           else
               aux = codeLine.substring(0, i + xssFunc.length());
           
           if (xss_final.endsWith(","))
                xss_final = xss_final.substring(0, xss_final.length()-1);
           ss = ss + aux + "(" + xss_final + ");";
        }
       return ss;
   }   
   
   private String getBuildAntiXSSFunction(int i){
      switch (i){
           case 0:
               return "buildEncodeOutput";
           case 1:
               return "buildPutStoreData";
           case 2:
               return "buildGetStoreData";
           default:
               return "";
       }
   }
 
   
   private String getAntiXSSFunction(int i){
       switch (i){
           case 0:
               return "san_out";
           case 1:
               return "san_wdata";
           case 2:
               return "san_rdata";
           default:
               return "";
       }  
   }
   
    
    public String buildEncodeOutput(Symbol sym){
        String protectedString, field;

        if (sym.getIsVariableSymbol())
            if (!sym.getName().contains("$"))
                field = "$" + sym.getName();
            else
                field = sym.getName();
        else
            field = sym.getName();
        
        protectedString = "san_out(" + field + ")";
        return protectedString;
    }
    
    public String buildPutStoreData(Symbol sym){
        String protectedString, field;

        if (sym.getIsVariableSymbol())
            if (!sym.getName().contains("$"))
                field = "$" + sym.getName();
            else
                field = sym.getName();
        else
            field = sym.getName();
        
        protectedString = "san_wdata(" + field + ")";
        return protectedString;
    
    }

    public String buildGetStoreData(Symbol sym){
        String protectedString, field;

        if (sym.getIsVariableSymbol())
            if (!sym.getName().contains("$"))
                field = "$" + sym.getName();
            else
                field = sym.getName();
        else
            field = sym.getName();
        
        protectedString = "san_rdata(" + field + ")";
        return protectedString;
    
    }    
   
    private LinesToCorrect getLinesToCorrect(String filename, Map MainLinesToCorrect){
        if (MainLinesToCorrect.containsKey(filename))
            return (LinesToCorrect) MainLinesToCorrect.get(filename);
        else{
            LinesToCorrect l = new LinesToCorrect(filename);
            MainLinesToCorrect.put(filename, l);
            return l;
        }
    }

    // Tell if the symbol is a define user function
    public TaintedTable getMtsUserFunction(SymbolTable st, Symbol sym) {
        TaintedTable mts_aux = null;
        Iterator <MethodSymbolTainted> it;        
        if (st.getHaveFunctions()){
            MethodTaintedTable mtt = GlobalDataXSS.MainFunctionsTaintedTable.get(sym.getFileSymbol());
            for(it = mtt.getListTaintedMembers().iterator(); it.hasNext();){
                MethodSymbolTainted mstt = it.next();
                if (mstt.getFunctionNameCall().equals(sym.getName()) && mstt.getLineNumberCall() == sym.getCodeLine()){
                    mts_aux = mstt.getFunctionTaintedTable();
                    return mts_aux;
                }
            }
        }

        if (st.getIncludeFiles().size() > 0){           
            Iterator <String> it1;
            SymbolTable st_inc;
            String name_st_inc;
            for(it1 = st.getIncludeFiles().iterator(); it1.hasNext();){
                name_st_inc = it1.next();
                st_inc = GlobalDataXSS.MainIncludeFilesTable.get(name_st_inc);
                if (st_inc.getHaveFunctions()){
                    MethodTaintedTable mtt = GlobalDataXSS.MainFunctionsTaintedTable.get(st.getScopeName());
                    for(it = mtt.getListTaintedMembers().iterator(); it.hasNext();){                
                        MethodSymbolTainted mstt = it.next();
                        if (mstt.getFunctionNameCall().equals(sym.getName()) && mstt.getLineNumberCall() == sym.getCodeLine()){                           
                            mts_aux = mstt.getFunctionTaintedTable();                           
                            return mts_aux;
                        }
                    }
                }
            }
        }
        return mts_aux;
    }

    public void define(Symbol sym, Scope scp, Boolean IsVariableSymbol) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public Boolean resolve(Symbol symb, TaintedTable mts, UntaintedTable mus) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public void resolveSymbol(Scope scp, Symbol sy, TaintedTable mts, UntaintedTable mus, String file) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public void resolveSymbolInclude(Scope scp1, TaintedTable mts, UntaintedTable mus) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public String resolveVarInclude(Scope scp, SymbolTable st) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public void print(Scope scp) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    //public void resolveSymbolFunction(MethodSymbol mt, Scope rootScope, TaintedTable mts, UntaintedTable mus, Map mift, String filename, Map mft, Map mst, int vulns, Map varsDB, LinesToCorrect MapLinesToCorrect, Map MainLinesToCorrect) {
    public void resolveSymbolFunctionSQLI(MethodSymbol mt, Scope rootScope, TaintedTable mts, UntaintedTable mus, Map mift, String filename, Map mft, Map mst, Map varsDB, Map mftt, Map MainLinesToCorrect) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public void resolveSymbolIncludeSQLI(Scope scp, TaintedTable mts, UntaintedTable mus, Map mift, String filename, Map mft, Map mst, Map varsDB, Map mftt, Map MainLinesToCorrect) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public Boolean verifyNumberVarList(int num_var){
        throw new UnsupportedOperationException("Not supported yet.");    
    }
    
    public void populateList(Scope scp_left, Scope scp_right, int num_var, TaintedTable mts, UntaintedTable mus, String filename){
        throw new UnsupportedOperationException("Not supported yet.");    
    }    
    
    public Boolean buildCorrectCodeInj(String fileInc, List UserInput, TaintedTable mts_princ, SymbolTable st, Map MainLinesToCorrect){
            throw new UnsupportedOperationException("Not supported yet.");
    }
    
    public Boolean buildCorrectXSS(String fileInc, List UserInput, TaintedTable mts_princ, SymbolTable st, Map MainLinesToCorrect){
            throw new UnsupportedOperationException("Not supported yet.");
    }

    public void resolveSymbolClass(TaintedTable mts, UntaintedTable mus, String filename) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

        public void printtt(String string, Scope cp){
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public void resolveSymbolParam(TaintedTable mts, UntaintedTable mus, String filename) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    public void resolveParam(Symbol symb, TaintedTable mts, UntaintedTable mus) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    public String buildCorrectSQL(String connDB, String nameDB, int lineMysqliBindParam, List UserInput, TaintedTable mts_princ, SymbolTable st, Map MainLinesToCorrect) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    public void copyScope(Scope src, Scope dest) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }
}
